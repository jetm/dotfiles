" General behavior
set autowrite       " auto saves changes when quitting and swiching buffer
set autoread        " Set to auto read when a file is changed from the outside
set nobackup        " do not keep a backup file
set magic           " Set magic on, for regular expressions
"set ttyfast         " smoother changes
set wrap            " enable wrap line

set pastetoggle=<F2>

autocmd FileType sh,awk,zsh setlocal tabstop=2 shiftwidth=2 softtabstop=2

" git commits
autocmd FileType gitcommit setlocal spell
au BufNewFile,BufRead *.git/COMMIT_EDITMSG set tw=72 noai noshowmatch
au BufNewFile,BufRead *.git/COMMIT_EDITMSG setlocal spell spelllang=en_us

" Sudo to write
map <leader>W :w !sudo tee % >/dev/null<CR>

"
" Trim trailing whitespace
"
function! ShowSpaces(...)
  let @/='\v(\s+$)|( +\ze\t)'
  let oldhlsearch=&hlsearch
  if !a:0
    let &hlsearch=!&hlsearch
  else
    let &hlsearch=a:1
  end
  return oldhlsearch
endfunction

function! TrimSpaces() range
  let oldhlsearch=ShowSpaces(1)
  execute a:firstline.",".a:lastline."substitute ///gec"
  let &hlsearch=oldhlsearch
endfunction

command! -bar -nargs=? ShowSpaces call ShowSpaces(<args>)
command! -bar -nargs=0 -range=% TrimSpaces <line1>,<line2>call TrimSpaces()
nnoremap <F12>           :ShowSpaces 1<CR>
nnoremap <Leader><F12>   m`:TrimSpaces<CR>``
vnoremap <Leader><S-F12> :TrimSpaces<CR>

highlight ExtraWhitespace ctermbg=red guibg=red
au ColorScheme * highlight ExtraWhitespace guibg=red
au BufEnter * match ExtraWhitespace /\s\+$/
au InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
au InsertLeave * match ExtraWhiteSpace /\s\+$/

let g:spf13_keep_trailing_whitespace = 1

"
" Settings indenting colors
"
let g:indent_guides_auto_colors = 0
let indent_guides_color_change_percent = 10
let indent_guides_guide_size = 1
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=darkgrey ctermbg=236
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=darkgrey ctermbg=237

"
" Perl Stuff
"
" my perl includes pod
let perl_include_pod = 1

" syntax color complex things like @{${"foo"}}
let perl_extended_vars = 1

if has("gui_running")
    colorscheme jellybeans
    set guifont=Ubuntu\ Mono\ 12
    set lines=50 columns=140
end

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Settings for C/C++ development
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Detect if the current file type is a C-like language.
au BufNewFile,BufRead c,cpp,objc,*.mm,*.cc,*.h call SetupForCLang()

" Configuration for C-like languages, based in Google C/C++ Style Guide
function! SetupForCLang()
    " Highlight lines longer than 80 characters.
    " au BufWinEnter * let w:m2=matchadd('ErrorMsg', '\%>80v.\+', -1)

    " Alternately, uncomment these lines to wrap at 80 characters.
    setlocal textwidth=80
    setlocal wrap

    " Use 2 spaces for indentation.
    setlocal shiftwidth=2
    setlocal tabstop=2
    setlocal softtabstop=2
    setlocal expandtab

    " Configure auto-indentation formatting.
    setlocal cindent
    setlocal cinoptions=h1,l1,g1,t0,i4,+4,(0,w1,W4
    setlocal indentexpr=GoogleCppIndent()
    let b:undo_indent = "setl sw< ts< sts< et< tw< wrap< cin< cino< inde<"
endfunction

" From https://github.com/vim-scripts/google.vim/blob/master/indent/google.vim
function! GoogleCppIndent()
    let l:cline_num = line('.')

    let l:orig_indent = cindent(l:cline_num)

    if l:orig_indent == 0 | return 0 | endif

    let l:pline_num = prevnonblank(l:cline_num - 1)
    let l:pline = getline(l:pline_num)
    if l:pline =~# '^\s*template' | return l:pline_indent | endif

    " TODO: I don't know to correct it:
    " namespace test {
    " void
    " ....<-- invalid cindent pos
    "
    " void test() {
    " }
    "
    " void
    " <-- cindent pos
    if l:orig_indent != &shiftwidth | return l:orig_indent | endif

    let l:in_comment = 0
    let l:pline_num = prevnonblank(l:cline_num - 1)
    while l:pline_num > -1
        let l:pline = getline(l:pline_num)
        let l:pline_indent = indent(l:pline_num)

        if l:in_comment == 0 && l:pline =~ '^.\{-}\(/\*.\{-}\)\@<!\*/'
            let l:in_comment = 1
        elseif l:in_comment == 1
            if l:pline =~ '/\*\(.\{-}\*/\)\@!'
                let l:in_comment = 0
            endif
        elseif l:pline_indent == 0
            if l:pline !~# '\(#define\)\|\(^\s*//\)\|\(^\s*{\)'
                if l:pline =~# '^\s*namespace.*'
                    return 0
                else
                    return l:orig_indent
                endif
            elseif l:pline =~# '\\$'
                return l:orig_indent
            endif
        else
            return l:orig_indent
        endif

        let l:pline_num = prevnonblank(l:pline_num - 1)
    endwhile

    return l:orig_indent
endfunction

"
" YouCompleteMe settings
"
" Avoid to ask load ycm_extra_conf.py configuration
let g:ycm_confirm_extra_conf = 0

" Auto-close the 'preview' window after the user accepts the offered
" completion string
let g:ycm_autoclose_preview_window_after_completion = 1

" Control number of characters user needs to type before identifier-based
" completion suggestions are trigger
let g:ycm_min_num_identifier_candidate_chars = 3

" YCM identifier completer will also collect identifiers from tags files
let g:ycm_collect_identifiers_from_tags_files = 1

nnoremap <F5> :YcmForceCompileAndDiagnostics<CR>

" Key mappings used to select completion string
let g:ycm_key_list_select_completion = ['<TAB>', 'j']
let g:ycm_key_list_previous_completion = ['<S-TAB>', 'k']

" Invoked :YcmShowDetailedDiagnostic
let g:ycm_key_detailed_diagnostics = ''

" Try to do the same than GoToDefinition and GoToDeclarion
nnoremap <leader>gt :YcmCompleter GoTo<CR>

" TODO: consider use this settings later
"nnoremap <leader>pg :YcmCompleter GoTo<CR>
"nnoremap <leader>pd :YcmCompleter GoToDefinition<CR>
"nnoremap <leader>pc :YcmCompleter GoToDeclaration<CR>

" For a global file
"let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'
"let g:ycm_collect_identifiers_from_tags_files = 1

"
" Syntastic settings
"
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_cpp_compiler_options = ' -std=c++11 -Wall -Wextra'
let g:syntastic_cpp_checkers = ['gcc', 'cpplint']
let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '⚠'

"
" C Format settings
"
let g:clang_format#style_options = {"Standard" : "C++11"}
" map to <Leader>cf in C++ code
autocmd FileType c,cpp,objc nnoremap <buffer><F4> :<C-u>ClangFormat<CR>
autocmd FileType c,cpp,objc vnoremap <buffer><F4> :ClangFormat<CR>
" if you install vim-operator-user
"autocmd FileType c,cpp,objc map <buffer><Leader>x <Plug>(operator-clang-format)
" Toggle auto formatting:
"nmap <Leader>C :ClangFormatAutoToggle<CR>

"
" cscope settings
"
if has("cscope")
    " use both cscope and ctag for 'ctrl-]', ':ta', and 'vim -t'
    " set cscopetag

    " check cscope for definition of a symbol before checking ctags
    " set to 1 if you want the reverse search order.
    set csto=0

    set cst
    set nocsverb
endif

"
" ctags settings
"
" Show Tagbar with F3 key, less error than ,tt using together with tmux
nnoremap <F3> :TagbarToggle<CR><C-w>=

" vim-cpp-enhanced-highlight settings
let g:cpp_class_scope_highlight = 1
