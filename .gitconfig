[user]
    name = Javier Tia
    email = javier.tia@gmail.com

[core]
    pager = less -FRsX
    editor = vim
    autocrlf = input
    safecrlf = true

[color]
    ui = auto

[i18n]
    commitencoding = UTF-8
    logoutputencoding = UTF-8

[merge]
    stat = true
    diff = vimdiff

[help]
    # Automatically correct and execute mistyped commands
    autocorrect = 1

[alias]
    br = branch
    ci = commit
    co = checkout
    st = status
    ls = ls-files
    rb = rebase
    dc = diff --cached
    sm = submodule

    # cherry-pick
    cp = cherry-pick -x

    # Logs
    lol = log --graph --decorate --pretty=oneline --abbrev-commit
    lola = log --graph --decorate --pretty=oneline --abbrev-commit --all

    # List new commits, of current branch, have been created by last command
    # (typically used after a "git pull")
    new = "!f() { ref=$(git symbolic-ref --short HEAD); git log ${ref}@{1}..${ref}@{0} \"$@\"; }; f"

    # Like <git new>, but it accepts branches as parameters, e.g.: git newp origin/BRANCH
    newp = "!f() { git log ${1}@{1}..${1}@{0} \"$@\"; }; f"

    # Editing/adding conflicted files
    edit-unmerged = "!f() { git diff --name-only --diff-filter=U ; }; ${EDITOR} `f`"
    add-unmerged = "!f() { git diff --name-only --diff-filter=U ; }; git add `f`"

    # While the empty tree sha1 4b825dc642cb6eb9a060e54bf8d69288fbee4904
    # is known to git, you may need to generate it.
    # git diff --check $(git empty-tree-sha1)
    # empty-tree-sha1 = hash-object -t tree /dev/null

    # Un-apply a Stash
    stash-unapply = !git stash show -p | git apply -R

    # remove remote-tracking branches that were deleted from the remote repo
    # trim = !git remote prune origin && git gc

    # search and replace text in all repo: git search-replace old_name new-new
    search-replace = "!f() { git grep -F --null --full-name --name-only -e \"$1\" -- . \
        | xargs -0 perl -i -p -e \"s/\\Q$1\\E/$2/g\"; }; f $1 $2"

    # show local commits
    lc = "!f() { ref=$(git symbolic-ref --short HEAD); git log origin/${ref}..${ref} \"$@\"; }; f"

    last = "!f() { git log -1 \"$@\"; }; f"

    # Commit any changes to files, squash them into the last commit and update its date
    fix-up-prev-ci = !git commit --all --amend --reuse-message=HEAD --date=\"$(date)\"

    # Print the name of the current branch
    current-branch = symbolic-ref --short HEAD

    # Print the name of the current upstream tracking branch
    upstream = !git config --get branch.$(git current-branch).remote || echo origin

    # Fetch all branches and rebase current branch against upstream/<BRANCH>
    rb-vs = "!f() { git fetch --all && git rebase $(git upstream)/$1; }; f $1"

    # Update all submodules
    spull = "!__git_spull() { git pull \"$@\" && git submodule sync --recursive && \
        git submodule update --init --recursive; }; __git_spull"

    # share local repository through git://HOST/ protocol
    serve = !git daemon --reuseaddr --verbose --base-path=. --export-all ./.git

[push]
    default = simple

[pull]
    rebase = true

[fetch]
    # Always prune when fetching and pulling
    prune = 1
    recurseSubmodules = on-demand

[branch]
    autosetuprebase = always

[diff]
    algorithm = patience
    submodule = log

[credential]
    # Set the cache to timeout after 8 hour (setting is in seconds)
    helper = cache --timeout=28800

